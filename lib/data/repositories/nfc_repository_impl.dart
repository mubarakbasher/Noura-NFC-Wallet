import 'package:dartz/dartz.dart';
import '../../core/errors/exceptions.dart';
import '../../core/errors/failures.dart';
import '../../domain/entities/nfc_token.dart';
import '../../domain/repositories/nfc_repository.dart';
import '../datasources/nfc_channel_datasource.dart';
import 'dart:async';

/// NFC Repository Implementation
class NfcRepositoryImpl implements NfcRepository {
  final NfcChannelDatasource nfcChannelDatasource;

  NfcRepositoryImpl(this.nfcChannelDatasource);

  @override
  Future<Either<Failure, bool>> isNfcAvailable() async {
    try {
      final isAvailable = await nfcChannelDatasource.checkNfcAvailability();
      return Right(isAvailable);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> enableHce() async {
    try {
      await nfcChannelDatasource.enableHce();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to enable HCE: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> disableHce() async {
    try {
      await nfcChannelDatasource.disableHce();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to disable HCE: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> startReaderMode() async {
    try {
      await nfcChannelDatasource.startReaderMode();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to start reader mode: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> stopReaderMode() async {
    try {
      await nfcChannelDatasource.stopReaderMode();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to stop reader mode: $e'));
    }
  }

  @override
  Future<Either<Failure, NfcToken>> generateNfcToken({
    required String userId,
    required String walletId,
    required String deviceId,
    required double amount,
  }) async {
    try {
      final encryptedData = await nfcChannelDatasource.generateNfcToken(
        userId: userId,
        walletId: walletId,
        deviceId: deviceId,
        amount: amount,
      );

      // Create NFC token entity with amount
      final token = NfcToken(
        userId: userId,
        walletId: walletId,
        amount: amount,
        timestamp: DateTime.now().millisecondsSinceEpoch,
        nonce: '', // Generated by native side
        deviceId: deviceId,
        signature: '', // Generated by native side
        encryptedData: encryptedData,
      );

      return Right(token);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to generate token: $e'));
    }
  }

  @override
  Future<Either<Failure, String>> readNfcTag() async {
    // This is handled via event stream in reader mode
    return const Left(NfcFailure('Use nfcEventStream for reading tags'));
  }

  @override
  Stream<Either<Failure, String>> get nfcEventStream {
    return nfcChannelDatasource.nfcEventStream.map<Either<Failure, String>>((event) {
      print('üì± NFC Event received in Flutter: $event');
      
      if (event['event'] == 'onTokenReceived') {
        final token = event['token'] as String;
        print('‚úÖ Token received! Length: ${token.length}');
        print('üìù Token preview: ${token.substring(0, token.length > 50 ? 50 : token.length)}...');
        return Right(token);
      } else if (event['event'] == 'onPaymentSent') {
        // Payment was successfully sent from this device (payer side)
        print('‚úÖ Payment sent successfully from this device!');
        return const Right('PAYMENT_SENT');
      } else {
        print('‚ùå NFC Error event: ${event['error']}');
        return Left(NfcFailure(event['error'] ?? 'Unknown NFC error'));
      }
    }).handleError((error) {
      print('‚ùå NFC Stream error: $error');
    }).transform(StreamTransformer.fromHandlers(
      handleError: (error, stackTrace, sink) {
        print('‚ùå NFC Stream transform error: $error');
        sink.add(Left(NfcFailure('Stream error: $error')));
      },
    ));
  }
}
