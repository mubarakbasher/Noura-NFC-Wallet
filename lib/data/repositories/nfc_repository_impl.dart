import 'package:dartz/dartz.dart';
import '../../core/errors/exceptions.dart';
import '../../core/errors/failures.dart';
import '../../domain/entities/nfc_token.dart';
import '../../domain/repositories/nfc_repository.dart';
import '../datasources/nfc_channel_datasource.dart';
import 'dart:async';

/// NFC Repository Implementation
class NfcRepositoryImpl implements NfcRepository {
  final NfcChannelDatasource nfcChannelDatasource;

  NfcRepositoryImpl(this.nfcChannelDatasource);

  @override
  Future<Either<Failure, bool>> isNfcAvailable() async {
    try {
      final isAvailable = await nfcChannelDatasource.checkNfcAvailability();
      return Right(isAvailable);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> enableHce() async {
    try {
      await nfcChannelDatasource.enableHce();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to enable HCE: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> disableHce() async {
    try {
      await nfcChannelDatasource.disableHce();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to disable HCE: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> startReaderMode() async {
    try {
      await nfcChannelDatasource.startReaderMode();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to start reader mode: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> stopReaderMode() async {
    try {
      await nfcChannelDatasource.stopReaderMode();
      return const Right(null);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to stop reader mode: $e'));
    }
  }

  @override
  Future<Either<Failure, NfcToken>> generateNfcToken({
    required String userId,
    required String walletId,
    required String deviceId,
    required String pin,
  }) async {
    try {
      final encryptedData = await nfcChannelDatasource.generateNfcToken(
        userId: userId,
        walletId: walletId,
        deviceId: deviceId,
      );

      // Create NFC token entity
      final token = NfcToken(
        userId: userId,
        walletId: walletId,
        amount: 0, // Amount set by merchant
        timestamp: DateTime.now().millisecondsSinceEpoch,
        nonce: '', // Generated by native side
        deviceId: deviceId,
        signature: '', // Generated by native side
        encryptedData: encryptedData,
      );

      return Right(token);
    } on NfcException catch (e) {
      return Left(NfcFailure(e.message, e.errorCode));
    } catch (e) {
      return Left(NfcFailure('Failed to generate token: $e'));
    }
  }

  @override
  Future<Either<Failure, String>> readNfcTag() async {
    // This is handled via event stream in reader mode
    return const Left(NfcFailure('Use nfcEventStream for reading tags'));
  }

  @override
  Stream<Either<Failure, String>> get nfcEventStream {
    return nfcChannelDatasource.nfcEventStream.map<Either<Failure, String>>((event) {
      if (event['event'] == 'onTokenReceived') {
        return Right(event['token'] as String);
      } else {
        return Left(NfcFailure(event['error'] ?? 'Unknown NFC error'));
      }
    }).handleError((error) {
      // This just logs the error, doesn't need to return anything
    }).transform(StreamTransformer.fromHandlers(
      handleError: (error, stackTrace, sink) {
        sink.add(Left(NfcFailure('Stream error: $error')));
      },
    ));
  }
}
